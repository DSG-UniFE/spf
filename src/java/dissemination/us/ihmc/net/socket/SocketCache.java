/*
 * SocketCache.java
 *
 * This file is part of the IHMC Util Library
 * Copyright (c) 1993-2016 IHMC.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 3 (GPLv3) as published by the Free Software Foundation.
 *
 * U.S. Government agencies and organizations may redistribute
 * and/or modify this program under terms equivalent to
 * "Government Purpose Rights" as defined by DFARS 
 * 252.227-7014(a)(12) (February 2014).
 *
 * Alternative licenses that allow for use within commercial products may be
 * available. Contact Niranjan Suri at IHMC (nsuri@ihmc.us) for details.
 */

package us.ihmc.net.socket;

import java.net.Socket;
import java.net.InetAddress;
import java.util.Hashtable;

import java.net.UnknownHostException;

import java.io.IOException;

/**
 * SocketCache is a utility class that can cache client-side connections to a server.
 * <p>
 * When a client asks for a connection, the cache is checked to see whether there is
 * an old but unused connection to the same host and port. If so, that connection is
 * returned. Otherwise, a new socket is created and returned.<p>
 * <p>
 * When a client is done with a connection, the client calls release on the SocketCache
 * instead of doing a close on the socket. The SocketCache then holds the socket using
 * the host and port as the key.
 * <p>
 * If a socket connection is left unused for sufficient a length of time, the connection
 * is automatically closed.
 * 
 * @author Andreas Klenk
 */
public class SocketCache extends Thread
{
    public static class Connection
    {
        public void Connection()
        {
            socket = null;
            obj = null;
        }
        
        public void Connection (Socket s, Object o)
        {
            socket = s;
            obj = o;
        }

        public Socket socket;
        public Object obj;
    }

    /**
     * Constructor to create a SocketCache.
     * Note that this class extends Thread and hence start() must be called
     * on the object after instantiation.
     * 
     * @param defaultCacheTime    the time in milliseconds for which connections should be kept open
     */
    public SocketCache (int defaultCacheTime)
    {
        _cacheTime = defaultCacheTime;
        this.setDaemon(true);
    }

    /**
     * Open a (TCP) socket connection to the specified host and port. Checks the cache of
     * already opened connections and returns one if available. Otherwise, a new socket
     * connection is created.
     * 
     * @param host      the host to which the connection should be established
     * @param port      the port on the host to which the connection should be established
     * 
     * @return the opened socket connection
     * 
     * @exception IOException               in case of an IO problem (generated by the constructor of java.net.Socket)
     * @exception UnknownHostException      in case the host cannot be resolved (generated by the constructor of java.net.Socket)
     */
    public synchronized Connection open (InetAddress host, int port)
        throws IOException, UnknownHostException
    {
        Connection conn = null;

        // Search for existing socket
        _FreeConnection fc = getConnection ((_FreeConnection)_cache.get (getHash(host,port)), host, port);

        if (fc != null) {
            // Cached connection found
            conn = fc.conn;
        }
        else {
            // Create a new connection
            conn = new Connection();
            conn.socket = new Socket(host,port);
        }
        return conn;
    }

    /**
     * Release a previously opened connection back to the cache. The connection
     * will be retained upto the timeout period and will be reused if open is called
     * again before the timeout period.
     * 
     * @param oldSocket
     */
    public synchronized void release (Connection conn)
    {
        // Put the socket back into the list till its time runs out
        _FreeConnection oldConnection = (_FreeConnection) (_cache.get (getHash (conn.socket.getInetAddress(), conn.socket.getPort())));
        _FreeConnection newConnection = new _FreeConnection (conn.socket.getInetAddress(), conn.socket.getPort(), conn, oldConnection);
        _cache.put (getHash (conn.socket.getInetAddress(), conn.socket.getPort()), newConnection);
    }

    public synchronized int cleanUp()
    {
        // Walks through the oldest entries and kills entries with an exceeded time limit
        // Returns number of sockets closed
        int removed = 0;
        long now = System.currentTimeMillis();
        for (_FreeConnection actual = _oldest; actual != null; actual=actual.younger) {
            if (actual.timeOfDeath<=now) {
                actual._removeConnection (actual.host, actual.port);
                removed++;
                try {
                    actual.conn.socket.close();
                }
                catch (IOException e) {};
            }
            else {
                // All coming connections are still alive now
                break;
            }
        }
        return removed;
    }

    public void setCacheTime (int defaultCacheTime)
    {
        _cacheTime=defaultCacheTime;
    }
    
    public synchronized void touch()
    {
        // Sets all expire times to actual time + cache time
        long expire = System.currentTimeMillis() + _cacheTime;
        _FreeConnection actual = _oldest;
        if (actual != null) {
            do {
                actual.timeOfDeath=expire;
                actual=actual.younger;
            }
            while (actual!=null);
        }
    }

    public void run()
    {
        // Periodically cleans up the entried
        while (true) {
            cleanUp();
            try {
                yield();
                Thread.sleep (_cacheTime / 4);
            }
            catch (InterruptedException e) {};
        }    
    }

    private int _cacheTime;
    private Hashtable _cache = new Hashtable();   //all connections indexed by Host&Port
                                                            //overflow is a linked list
                                                            //longest untouched entries at the end of the list

    private _FreeConnection _oldest = null;                 //maintains a timley sequential order of the connections
    private _FreeConnection _youngest = null;

    private class _FreeConnection
    {//free and open Socket to a specific host&port
        public InetAddress host;
        public int port;
        Connection conn;
        long timeOfDeath;
        
        _FreeConnection next;                               //linked list for hash buckets
        _FreeConnection previous;

        _FreeConnection younger;                            //linked list for timely sequence of released connections
        _FreeConnection older;
        
        _FreeConnection (InetAddress newHost, int newPort, Connection newConn, _FreeConnection nextConnection)
        {//creates a Connection and links it to nextConnection
            host=newHost;
            port=newPort;
            conn=newConn;
            timeOfDeath=System.currentTimeMillis() + _cacheTime;

            next=nextConnection;
            previous=null;
            if (nextConnection!=null) nextConnection.previous=this;
            
            if (_youngest!=null)
            {
                _youngest.younger=this;
                this.older=_youngest;
                this.younger=null;
            }else{
                older=younger=null;
                _oldest=this;
            }
            _youngest=this;
        }
        
        public void _removeConnection (InetAddress Host, int Port)
        {
            if (previous!=null) previous.next=next;             //take it out of the linked list and the time sequence
            if (next!=null) next.previous=previous;

            if (this==_oldest) _oldest=younger;
            else older.younger=younger;  
            if (this==_youngest) _youngest=older;
            else younger.older=older;

            if ((previous==null) && (next==null))               //nothing left remove key from hashtable
                _cache.remove(getHash(Host,Port));
            else if (previous==null) _cache.put(getHash(Host,Port),next);
        }
        
    }
    
    private _FreeConnection getConnection (_FreeConnection start, InetAddress Host, int Port)
    {//searches for a given host&port through the linked list and takes it out of the list if found otherwise returns null
        _FreeConnection next = start;
        while ((next!=null) && ((next.host!=Host) && (next.port!=Port)) )
        {
            next=next.next;
        }
        if (next!=null)
        {
            next._removeConnection(Host,Port);
        };
         return next;
    }

    private static Integer getHash (InetAddress host, int port)
    {
        return new Integer(host.hashCode() + port);
    }

    protected void finalize()
    {
        
    }
}
